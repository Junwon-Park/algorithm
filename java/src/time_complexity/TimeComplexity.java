package time_complexity;

// 시간 복잡도 유형
// 빅-오메가: 최선(Best case)일 때의 연산 횟수를 나타낸 표기법
// 빅-세타: 보통(Average case)일 때의 연산 횟수를 나타낸 표기법
// 빅-오: 최악(Worst case)일 때의 연산 횟수를 나타낸 표기법

/** 코딩 테스트에서는 최악의 경우인 빅-오를 염두해서 문제를 풀어야 한다.
 * 그 이유는 한 문제에서 문제를 체점할 때, 다양한 테스트를 수행해 모든 케이스를 통과해야만 합격이기 떄문이다.
 * 테스트 케이스들 중 적은 연산 횟수(연산해야 하는 데이터의 크기가 작은 경우) 부터 많은 연산 횟수(연산해야 하는 데이터의 크기가 큰 경우) 까지의 모든 테스트를 통과해야 한다.
 * 그렇기 때문에 연산 횟수가 많은 최악의 경우인 빅-오를 염두해서 문제를 풀어야 어떤 텍스트 케이스가 나와도 문제를 통과할 수 있다.
 * */

/**
 * 알고리즘에서 시간 복잡도를 나타내는 방법은 여러 가지가 있다.(위에서 부터 아래로 연산 시간이 적은 것 부터 많은 것 순이다.)
 * O(1): 단 한 번의 연산으로 결과를 얻을 수 있는 시간 복잡도를 의미한다.

 * O(logN): O(1) 다음으로 연산 횟수가 적은 표기법으로 만약 100개의 데이터를 받았을 떄,
    * logN 시간 복잡도를 가진 알고리즘으로 연산 시, 2^7이 128로 100 이상이 되므로 7번의 연산으로 결과를 얻을 수 있다는 의미가 된다.

 * O(N): N은 주어진 데이터의 수와 연산 횟수가 동일한 시간 복잡도를 의미하는 표기법이다.
    * 만약 100개의 데이터가 주어지면 100번의 연산으로 결과를 얻을 수 있디는 것을 의미한다.

 * O(NlogN, NlogN == N * logN): 100개의 데이터가 주어졌을 때, 100 * log100의 시간 복잡도를 가진다.
    * 계산해보면 100 * 7(2^7이 128로 100 이상이다.) == 700이므로 약 700번의 연산을 통해 결과를 얻을 수 있다는 것을 의미한다.

 * O(N^2): 100개의 데이터가 주어지면 100^2(10000)의 시간 복잡도를 가진다.
    * 데이터가 많아지면 연산 횟수가 늘어나는 양이 위의 표기법들 보다 훨씬 많으므로 상대적으로 시간이 많이 걸린다는 것을 의미한다.

 * O(2^N): 2의 주어진 데이터의 수만크의 승을 한 만큼의 연산으로 결과를 얻을 수 있다는 것을 의미하는 시간 복잡도이다.
    * 주어진 데이터가 많아질 수록 연산에 걸리는 시간이 가파르게 증가하므로 이 시간 복잡도를 가진 알고리즘은 사용을 지양하는 것이 좋다.

 * O(N!): 데이터의 수가 많아질수록 연산 시간이 기하 급수적으로 증가한다.
    * 이 시간복잡도를 가진 알고리즘은 사용을 지양하는 것이 좋다.

 * 프로그램에서 연산 횟수는 1초에 약 1억 번으로 생각하면 된다.(N초에 N억 번 연산)
 * 위 모든 표기법이 빅-오 표기법으로 표현하는 시간 복잡도이며 빅-오는 가장 최악의 경우 위와 같은 시간 복잡도를 갖는 다는 것을 의미한다.
 */

public class TimeComplexity {
    public static void main(String[] args) {
        /** 적합한 알고리즘을 찾는 방법 */

        // 시간 복잡도 예제 1, 수 정렬(Sort)하기
        /**
         * N개의 수가 주어졌을 때 이를 오름 차순 정렬하는 프로그램을 작성하시오.
         * 시간 제한 2초(1초에 1억 번 연산한다고 생각하면 되기 떄문에
         * 시간 제한 2초는 2억 번 이내의 연산으로 결과를 얻는 알고리즘으로 풀어야 한다는 의미이다.)

         * 입력
            * 1번째 줄에 수의 개수 N(1 <= N <= 1,000,000),
            * 2번째 줄 부터는 N개의 줄에 숫자가 주어진다.
            * 이 수는 절댓 값이 1,000,000보다 작거나 같은 정수다. 수는 중복되지 않는다.

         * 출력: 1번째 줄부터 N개의 줄에 오름차순 정렬한 결과를 1줄에 1개 씩 출력한다.
            * 입력 예제(아래 처럼 입력 되면)
                * 5
                * 4
                * 3
                * 2
                * 1
            * 출력 예제(아래 처럼 출력되어야 한다.)
                * 1
                * 2
                * 3
                * 4
                * 5

         *  문제에서 N(1 <= N <= 1,000,000)의 데이터 개수가 주어진다고 했다.
         *  주어지는 데이터의 수인 N은 1 이상 1,000,000 이하이다.
         *  알고리즘 문제를 풀 때는 빅-오 즉, 최악의 케이스를 고려해서 풀어야 하기 때문에
         *  N을 문제에서 주어진 데이터의 최대 개수인 1,000,000으로 잡는다.
         *  그럼 이제 주어진 데이터의 최대 수를 알고리즘에 대입했을 때
         *  연산 횟수가 문제에 주어진 2억 번(제한 시간 2초로 2억 번 이내 연산 제한) 이내인 알고리즘을 선택해야 한다.

         * 연산 횟수 계산하는 방법은 빅-오 포기법의 N에 문제에 주어진 데이터의 최대 수를 대입하면 된다.

         * 알고리즘 적합성 평가
            * 정렬 알고리즘 중 버블 정렬과 병합 정렬 두 가지만 두고 예를 들면,

            * 버블 정렬은 O(N^2)의 시간 복잡도를 가진다.
            * 연산 횟수를 구하기 위해 빅-오 표기법의 N에 문제에 주어진 데이터의 최대 수인 1,000,000을 대입하면
            * 1,000,000^2 = 1,000,000,000,000의 연산 횟수가 나온다.
            * 하지만 문제에서 제한 시간을 2초로 제한했고 제한 시간 2초는 2억 번 이내의 연산 횟수 제한을 의미하기 때문에
            * 1,000,000,000,000 > 200,000,000으로 2억 번의 연산 횟수 초과로 이 문제에 버블 정렬 알고리즘은 부적합하다.

            * 병합 정렬은 O(NlogN)의 시간 복잡도를 가진다.(NlogN은 N * logN과 같다.)
             * 마찬가지로 연산 횟수를 구하면 1,000,000 * log1,000,000이므로 1,000,000 * 20(2^20 정도가 1,000,000 이상이 된다.) = 약 2,000,0000의 연산 횟수이다.
             * 그렇다면 2,000,0000 < 200,000,000으로 2억 번의 1/10의 연산 횟수가 나오므로 문제의 제한 시간 이내에 결과가 나오므로 이 문제에 병합 정렬은 적합하다.
         */

        /**
         * 위 방법으로 문제에 알맞은 시간 복잡도를 가진 알고리즘을 찾았다면 해당 알고리즘으로 로직을 효율적으로 짜는 것은 중요하다.
         * 내가 작성한 로직이 효율적인지 확인하는 방법은 아래와 같다.
            * 시간 복잡도의 N 앞에 붙는 상수는 제외한다.(정확히는 아래 예제를 보면 이해할 수 있다.)
            * 시간 복잡도의 기준은 가장 많이 중첩된 반복을 기준으로 한다.
         */

        TimeComplexity tc = new TimeComplexity();
        tc.operationCountN(); // 연산 횟수 N = 10,0000번
        tc.operationCount3N(); // 연산 횟수 3N = 3 * 10,0000번 = 30,0000번
        // 하지만 위에서 "시간 복잡도의 N 앞에 붙는 상수는 제외한다."고 했기 때문에 3N의 3을 제외,
        // operationCount3N();의 시간 복잡도도 N이다. 10N이어도 중첩된 반복문이 아니라면 N과 같다고 본다.
        // 그러므로 operationCountN()과 operationCount3N() 모두 시간 복잡도는 O(N)이다.

        tc.operationCount2PowerOfN(); // 연산 횟수 N^2 = 100000^2번 = 10,000,000,000번
        // 중첩되지 않은 반복문이 100개면 100N이며 상수는 제외하므로 그냥 O(N)으로 보기 때문에 10,0000번의 연산 횟수와 같다.
        // 하지만 중첩 된 반복문 두 개는 N^2의 시간 복잡도를 가지므로 N^2 = 100000^2번 = 10,000,000,000번의 연산 횟수를 가지게 된다.
        // 그리고 만약 operationCount2PowerOfN() 함수 내부에 이중 중첩 반복문 하나 그리고 중첩되지 않은 반복문 10개가 있더라도
        // 빅-오 표기법으로 시간 복잡도를 나타내기 때문에 이 중 가장 최악의 케이스인 이중 중첩 반복문을 기준으로 시간 복잡도를 계산한다.
        // 즉 이 함수의 시간 복잡도는 O(N^2)이다.

        /**
         * 알고리즘 문제를 풀 때, 중요한 것은 크게 아래 두 가지이다.
            * 1. 알맞은 알고리즘 선택
            * 2. 비효율적인 로직 찾아서 효율적으로 개선(알맞은 알고리즘으로 결과도 잘 출력 되지만 시간 초과가 나는 경우)
         */
    }
    // 연산 횟수가 N인 경우
    public void operationCountN() {
        int N = 100000;
        int cnt = 0;

        // 반복문을 1번만 실행했기 때문에 이 함수의 시간 복잡도는 O(N)이다.
        for (int i = 0; i < N; i++) {
            System.out.println("연산 횟수: " + cnt++);
        }
    }

    // 연산 횟수가 3N인 경우
    public void operationCount3N() {
        int N = 100000;
        int cnt = 0;

        // 중첩되지 않은 반복문을 각각 3번 수행했다.
        // 이 경우 반복문을 3번 수행했기 때문에 이 함수의 시간 복잡도는 3N이지만
        // 알고리즘에서 빅-오 표기법은 중첩되지 않은 반복문을 3번 반복하여 3N이라도 상수를 제외한 N이라고 본다.
        // 즉, 중첩되지 않은 반복문 여러 개는 10N이라도 그냥 N과 같다.
        for (int i = 0; i < N; i++) {
            System.out.println("연산 횟수: " + cnt++);
        }
        for (int i = 0; i < N; i++) {
            System.out.println("연산 횟수: " + cnt++);
        }
        for (int i = 0; i < N; i++) {
            System.out.println("연산 횟수: " + cnt++);
        }
    }
    
    // 연산 횟수가 N^2인 경우
    public void operationCount2PowerOfN() {
        int N = 100000;
        int cnt = 0;

        // 중첩 된 반복문 두 개는 N^2의 시간 복잡도를 가지므로 N^2 = 100000^2번 = 10,000,000,000번의 연산 횟수를 가지게 된다.
        // 그러므로 이 함수의 시간 복잡도는 O(N^2)이다.
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                System.out.println("연산 횟수: " + cnt++);
            }
        }
    }
}