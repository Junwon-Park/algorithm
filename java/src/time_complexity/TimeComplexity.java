package time_complexity;

// 시간 복잡도 유형
// 빅-오메가: 최선(Best case)일 때의 연산 횟수를 나타낸 표기법
// 빅-세타: 보통(Average case)일 때의 연산 횟수를 나타낸 표기법
// 빅-오: 최악(Worst case)일 때의 연산 횟수를 나타낸 표기법

/** 코딩 테스트에서는 최악의 경우인 빅-오를 염두해서 문제를 풀어야 한다.
 * 그 이유는 한 문제에서 문제를 체점할 때, 다양한 테스트를 수행해 모든 케이스를 통과해야만 합격이기 떄문이다.
 * 테스트 케이스들 중 적은 연산 횟수(연산해야 하는 데이터의 크기가 작은 경우) 부터 많은 연산 횟수(연산해야 하는 데이터의 크기가 큰 경우) 까지의 모든 테스트를 통과해야 한다.
 * 그렇기 때문에 연산 횟수가 많은 최악의 경우인 빅-오를 염두해서 문제를 풀어야 어떤 텍스트 케이스가 나와도 문제를 통과할 수 있다.
 * */

/**
 * 알고리즘에서 시간 복잡도를 나타내는 방법은 여러 가지가 있다.(위에서 부터 아래로 연산 시간이 적은 것 부터 많은 것 순이다.)
 * O(1): 단 한 번의 연산으로 결과를 얻을 수 있는 시간 복잡도를 의미한다.

 * O(logN): O(1) 다음으로 연산 횟수가 적은 표기법으로 만약 100개의 데이터를 받았을 떄,
    * logN 시간 복잡도를 가진 알고리즘으로 연산 시, 2^7이 128로 100 이상이 되므로 7번의 연산으로 결과를 얻을 수 있다는 의미가 된다.

 * O(N): N은 주어진 데이터의 수와 연산 횟수가 동일한 시간 복잡도를 의미하는 표기법이다.
    * 만약 100개의 데이터가 주어지면 100번의 연산으로 결과를 얻을 수 있디는 것을 의미한다.

 * O(NlogN, NlogN == N * logN): 100개의 데이터가 주어졌을 때, 100 * log100의 시간 복잡도를 가진다.
    * 계산해보면 100 * 7(2^7이 128로 100 이상이다.) == 700이므로 약 700번의 연산을 통해 결과를 얻을 수 있다는 것을 의미한다.

 * O(N^2): 100개의 데이터가 주어지면 100^2(10000)의 시간 복잡도를 가진다.
    * 데이터가 많아지면 연산 횟수가 늘어나는 양이 위의 표기법들 보다 훨씬 많으므로 상대적으로 시간이 많이 걸린다는 것을 의미한다.

 * O(2^N): 2의 주어진 데이터의 수만크의 승을 한 만큼의 연산으로 결과를 얻을 수 있다는 것을 의미하는 시간 복잡도이다.
    * 주어진 데이터가 많아질 수록 연산에 걸리는 시간이 가파르게 증가하므로 이 시간 복잡도를 가진 알고리즘은 사용을 지양하는 것이 좋다.

 * O(N!): 데이터의 수가 많아질수록 연산 시간이 기하 급수적으로 증가한다.
    * 이 시간복잡도를 가진 알고리즘은 사용을 지양하는 것이 좋다.

 * 프로그램에서 연산 횟수는 1초에 약 1억 번으로 생각하면 된다.(N초에 N억 번 연산)
 * 위 모든 표기법이 빅-오 표기법으로 표현하는 시간 복잡도이며 빅-오는 가장 최악의 경우 위와 같은 시간 복잡도를 갖는 다는 것을 의미한다.
 */

public class TimeComplexity {
    public static void main(String[] args) {
        // 시간 복잡도 예제 1

    }
}