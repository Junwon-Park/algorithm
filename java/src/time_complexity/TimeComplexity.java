package time_complexity;

// 시간 복잡도 유형
// 빅-오메가: 최선(Best case)일 때의 연산 횟수를 나타낸 표기법
// 빅-세타: 보통(Average case)일 때의 연산 횟수를 나타낸 표기법
// 빅-오: 최악(Worst case)일 때의 연산 횟수를 나타낸 표기법

/** 코딩 테스트에서는 최악의 경우인 빅-오를 염두해서 문제를 풀어야 한다.
 * 그 이유는 한 문제에서 문제를 체점할 때, 다양한 테스트를 수행해 모든 케이스를 통과해야만 합격이기 떄문이다.
 * 테스트 케이스들 중 적은 연산 횟수(연산해야 하는 데이터의 크기가 작은 경우) 부터 많은 연산 횟수(연산해야 하는 데이터의 크기가 큰 경우) 까지의 모든 테스트를 통과해야 한다.
 * 그렇기 때문에 연산 횟수가 많은 최악의 경우인 빅-오를 염두해서 문제를 풀어야 어떤 텍스트 케이스가 나와도 문제를 통과할 수 있다.
 * */

/**
 * 알고리즘에서 시간 복잡도를 나타내는 방법은 여러 가지가 있다.(위에서 부터 아래로 연산 시간이 적은 것 부터 많은 것 순이다.)
 * O(1): 단 한 번의 연산으로 결과를 얻을 수 있는 시간 복잡도를 의미한다.

 * O(logN): O(1) 다음으로 연산 횟수가 적은 표기법으로 만약 100개의 데이터를 받았을 떄,
    * logN 시간 복잡도를 가진 알고리즘으로 연산 시, 2^7이 128로 100 이상이 되므로 7번의 연산으로 결과를 얻을 수 있다는 의미가 된다.

 * O(N): N은 주어진 데이터의 수와 연산 횟수가 동일한 시간 복잡도를 의미하는 표기법이다.
    * 만약 100개의 데이터가 주어지면 100번의 연산으로 결과를 얻을 수 있디는 것을 의미한다.

 * O(NlogN, NlogN == N * logN): 100개의 데이터가 주어졌을 때, 100 * log100의 시간 복잡도를 가진다.
    * 계산해보면 100 * 7(2^7이 128로 100 이상이다.) == 700이므로 약 700번의 연산을 통해 결과를 얻을 수 있다는 것을 의미한다.

 * O(N^2): 100개의 데이터가 주어지면 100^2(10000)의 시간 복잡도를 가진다.
    * 데이터가 많아지면 연산 횟수가 늘어나는 양이 위의 표기법들 보다 훨씬 많으므로 상대적으로 시간이 많이 걸린다는 것을 의미한다.

 * O(2^N): 2의 주어진 데이터의 수만크의 승을 한 만큼의 연산으로 결과를 얻을 수 있다는 것을 의미하는 시간 복잡도이다.
    * 주어진 데이터가 많아질 수록 연산에 걸리는 시간이 가파르게 증가하므로 이 시간 복잡도를 가진 알고리즘은 사용을 지양하는 것이 좋다.

 * O(N!): 데이터의 수가 많아질수록 연산 시간이 기하 급수적으로 증가한다.
    * 이 시간복잡도를 가진 알고리즘은 사용을 지양하는 것이 좋다.

 * 프로그램에서 연산 횟수는 1초에 약 1억 번으로 생각하면 된다.(N초에 N억 번 연산)
 * 위 모든 표기법이 빅-오 표기법으로 표현하는 시간 복잡도이며 빅-오는 가장 최악의 경우 위와 같은 시간 복잡도를 갖는 다는 것을 의미한다.
 */

public class TimeComplexity {
    public static void main(String[] args) {
        /** 적합한 알고리즘을 찾는 방법 */

        // 시간 복잡도 예제 1, 수 정렬(Sort)하기
        /**
         * N개의 수가 주어졌을 때 이를 오름 차순 정렬하는 프로그램을 작성하시오.
         * 시간 제한 2초(1초에 1억 번 연산한다고 생각하면 되기 떄문에
         * 시간 제한 2초는 2억 번 이내의 연산으로 결과를 얻는 알고리즘으로 풀어야 한다는 의미이다.)

         * 입력
            * 1번째 줄에 수의 개수 N(1 <= N <= 1,000,000),
            * 2번째 줄 부터는 N개의 줄에 숫자가 주어진다.
            * 이 수는 절댓 값이 1,000,000보다 작거나 같은 정수다. 수는 중복되지 않는다.

         * 출력: 1번째 줄부터 N개의 줄에 오름차순 정렬한 결과를 1줄에 1개 씩 출력한다.
            * 입력 예제(아래 처럼 입력 되면)
                * 5
                * 4
                * 3
                * 2
                * 1
            * 출력 예제(아래 처럼 출력되어야 한다.)
                * 1
                * 2
                * 3
                * 4
                * 5

         *  문제에서 N(1 <= N <= 1,000,000)의 데이터 개수가 주어진다고 했다.
         *  주어지는 데이터의 수인 N은 1 이상 1,000,000 이하이다.
         *  알고리즘 문제를 풀 때는 빅-오 즉, 최악의 케이스를 고려해서 풀어야 하기 때문에
         *  N을 문제에서 주어진 데이터의 최대 개수인 1,000,000으로 잡는다.
         *  그럼 이제 주어진 데이터의 최대 수를 알고리즘에 대입했을 때
         *  연산 횟수가 문제에 주어진 2억 번(제한 시간 2초로 2억 번 이내 연산 제한) 이내인 알고리즘을 선택해야 한다.

         * 연산 횟수 계산하는 방법은 빅-오 포기법의 N에 문제에 주어진 데이터의 최대 수를 대입하면 된다.

         * 알고리즘 적합성 평가
            * 정렬 알고리즘 중 버블 정렬과 병합 정렬 두 가지만 두고 예를 들면,

            * 버블 정렬은 O(N^2)의 시간 복잡도를 가진다.
            * 연산 횟수를 구하기 위해 빅-오 표기법의 N에 문제에 주어진 데이터의 최대 수인 1,000,000을 대입하면
            * 1,000,000^2 = 1,000,000,000,000의 연산 횟수가 나온다.
            * 하지만 문제에서 제한 시간을 2초로 제한했고 제한 시간 2초는 2억 번 이내의 연산 횟수 제한을 의미하기 때문에
            * 1,000,000,000,000 > 200,000,000으로 2억 번의 연산 횟수 초과로 이 문제에 버블 정렬 알고리즘은 부적합하다.

            * 병합 정렬은 O(NlogN)의 시간 복잡도를 가진다.(NlogN은 N * logN과 같다.)
             * 마찬가지로 연산 횟수를 구하면 1,000,000 * log1,000,000이므로 1,000,000 * 20(2^20 정도가 1,000,000 이상이 된다.) = 약 2,000,0000의 연산 횟수이다.
             * 그렇다면 2,000,0000 < 200,000,000으로 2억 번의 1/10의 연산 횟수가 나오므로 문제의 제한 시간 이내에 결과가 나오므로 이 문제에 병합 정렬은 적합하다.
         */
        

    }
}